{"id":"ADR-000","title":"ADR Format and Process","status":"approved","decision":"Architecture Decision Records follow this JSONL format with required fields: id, title, status, decision, rationale, createdAt, updatedAt. Statuses: proposed → approved | rejected | deferred | suspended | superseded.","rationale":"Consistent format enables tooling, searchability, and clear decision history. JSONL allows line-by-line processing and easy appending.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["meta"],"categories":{"001-019":"Tooling & Infrastructure","020-029":"Code Quality & Patterns","030-039":"CLI & Configuration","040-049":"Web & API","050-059":"Data & Storage","100-107":"UX Principles","120-129":"Testing & Quality Gates","130-139":"CI/CD & Security","140-149":"Standards & Governance"}}
{"id":"ADR-001","title":"Language Version","status":"approved","decision":"Rust 2021 edition, MSRV 1.75+ (for async fn in traits, C-string literals)","rationale":"2021 edition provides modern syntax, cleaner captures in closures, IntoIterator for arrays. Pin MSRV in Cargo.toml rust-version field for CI enforcement.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","runtime"],"config":{"Cargo.toml":{"rust-version":"1.75","edition":"2021"}}}
{"id":"ADR-002","title":"Type System and Static Analysis","status":"approved","decision":"Native Rust type system with clippy pedantic lints for additional static analysis","rationale":"Rust's type system is among the strongest available. Clippy pedantic catches additional issues and encourages idiomatic patterns.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","typing"],"config":{"clippy":{"warn":["clippy::pedantic","clippy::nursery"],"allow":["clippy::module_name_repetitions"]}}}
{"id":"ADR-003","title":"Testing Framework","status":"approved","decision":"Built-in #[test] and cargo test. No external test runner.","rationale":"Rust's native testing is excellent. Use #[cfg(test)] modules for unit tests, tests/ directory for integration tests. Add rstest for parameterized tests if needed.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","testing"],"libraries":{"parameterized":"rstest","mocking":"mockall","assertions":"assert_matches (std), or pretty_assertions","temp_files":"tempfile"}}
{"id":"ADR-004","title":"Code Markers Convention","status":"approved","decision":"Two-tier marker system: (1) Inline markers (TODO, FIXME, HACK) for active development only—must be resolved before PR merge. (2) Structured tracking (issue tracker, metadata files) for persistent work items with ownership and priority.","rationale":"Unstructured markers accumulate as invisible technical debt. Requiring promotion to structured tracking ensures accountability and visibility.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["conventions","code-quality"]}
{"id":"ADR-005","title":"Async I/O","status":"approved","decision":"tokio for async runtime, with tokio::fs for file operations","rationale":"Most mature async runtime, excellent ecosystem (axum, reqwest, sqlx). Use #[tokio::main] for binaries. For sync-heavy CLI tools, async may be unnecessary.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","async"],"features":["rt-multi-thread","fs","sync","macros"]}
{"id":"ADR-006","title":"Package Manager","status":"approved","decision":"Cargo (built-in) with Cargo.lock committed for binaries","rationale":"Cargo is Rust's native package manager with excellent dependency resolution, workspaces, and feature flags. No alternative needed.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"]}
{"id":"ADR-007","title":"Linter and Formatter","status":"approved","decision":"rustfmt for formatting, clippy with pedantic lints for linting","rationale":"Both ship with rustup, zero additional deps. Clippy catches common mistakes, pedantic encourages idiomatic Rust. Deny warnings in CI.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"],"config":{"rustfmt.toml":{"edition":"2021","max_width":100}}}
{"id":"ADR-008","title":"Git Hooks","status":"approved","decision":"pre-commit with cargo fmt --check, cargo clippy, cargo test","rationale":"Same pre-commit framework as Python projects. Consistent DX across polyglot repos.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"],"hooks":["cargo fmt --check","cargo clippy -- -D warnings","cargo test"]}
{"id":"ADR-009","title":"Project Structure","status":"approved","decision":"Standard Cargo layout: src/lib.rs for library, src/main.rs for binary, tests/ for integration tests","rationale":"Cargo conventions are well-established. Separating lib.rs from main.rs enables both library usage and CLI in one crate.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["conventions","architecture"],"structure":{"src/lib.rs":"Library root (pub API)","src/main.rs":"Binary entry point (thin wrapper)","src/bin/":"Additional binaries","tests/":"Integration tests","benches/":"Benchmarks (criterion)","examples/":"Example binaries"}}
{"id":"ADR-010","title":"Build Tool","status":"approved","decision":"Cargo for building, with build.rs for code generation if needed","rationale":"Cargo handles compilation, linking, and optimization. Build scripts enable compile-time code generation.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","build"]}
{"id":"ADR-011","title":"Configuration Management","status":"approved","decision":"config crate with layered configuration (file, env, defaults)","rationale":"Supports multiple formats (TOML, JSON, YAML), environment variable overrides, and type-safe deserialization via serde.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","configuration"],"crate":"config"}
{"id":"ADR-012","title":"Serialization and Validation","status":"approved","decision":"serde with serde_json/serde_yaml for serialization, validator crate for validation","rationale":"De facto standard, zero-cost abstractions via derive macros, excellent ecosystem support. Use #[serde(deny_unknown_fields)] for strict parsing.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","validation"],"derives":["Serialize","Deserialize","Validate"]}
{"id":"ADR-013","title":"Logging and Tracing","status":"approved","decision":"tracing over log/env_logger","rationale":"Structured, span-based instrumentation. Works for both logging and distributed tracing. Use tracing-subscriber for output formatting.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","observability"],"crates":{"core":"tracing","subscriber":"tracing-subscriber","json":"tracing-subscriber with json feature"}}
{"id":"ADR-014","title":"Dead Code Detection","status":"approved","decision":"Built-in dead_code lint plus clippy's unused warnings","rationale":"Rust compiler warns on unused code by default. Clippy adds additional unused detection. Deny warnings in CI.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","maintenance"],"lints":["dead_code","unused_imports","unused_variables"]}
{"id":"ADR-015","title":"Development Environment","status":"approved","decision":"rust-toolchain.toml for version pinning, cargo-watch for dev iteration","rationale":"rust-toolchain.toml ensures consistent toolchain across team. cargo-watch enables automatic rebuild on file changes.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"]}
{"id":"ADR-016","title":"Dependency Management","status":"approved","decision":"Cargo.lock committed for binaries, semver ranges in Cargo.toml","rationale":"Lock file ensures reproducible builds for applications. Libraries should not commit Cargo.lock to allow downstream flexibility.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dependencies"]}
{"id":"ADR-017","title":"Documentation","status":"approved","decision":"Rustdoc with doc-tests, README.md with cargo-readme sync","rationale":"Rustdoc is excellent, doc-tests ensure examples compile. Use #![warn(missing_docs)] for public API coverage.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["documentation","conventions"],"lints":["missing_docs","rustdoc::missing_crate_level_docs"]}
{"id":"ADR-020","title":"Code Quality Principles","status":"approved","decision":"Adopt ownership patterns, SOLID principles adapted for Rust, and idiomatic Rust while prioritizing shipping. Perfect is the enemy of good.","rationale":"Sustainable code requires proven principles balanced with pragmatic delivery. Leverage Rust's ownership for correctness. Refactor when patterns emerge, not in anticipation.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","principles"],"principles":{"Ownership":"Use borrowing and lifetimes correctly for memory safety","SOLID":"Adapted: traits for interfaces, composition over inheritance","Idiomatic":"Follow Rust API guidelines, use iterators, avoid unwrap in libraries"}}
{"id":"ADR-021","title":"Error Handling","status":"approved","decision":"thiserror for library errors, anyhow for application/binary errors. Native Result<T, E> everywhere.","rationale":"Rust's Result is explicit error handling. thiserror generates Display/Error impls with zero runtime cost. anyhow provides ergonomic error chaining for binaries.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns"],"libraries":{"lib":"thiserror","bin":"anyhow"},"pattern":"fn foo() -> Result<T, MyError>"}
{"id":"ADR-022","title":"No Mock Data in Production Code","status":"approved","decision":"Mock data only in test modules (#[cfg(test)]). Production code uses proper data loading, empty states, and error handling.","rationale":"Mock data in production creates confusion, makes debugging harder, and risks shipping to users. Forces proper implementation of data flows.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","testing"]}
{"id":"ADR-023","title":"Data Structures","status":"approved","decision":"Use structs with derive macros for data containers, traits for polymorphism","rationale":"Structs with derives (Debug, Clone, PartialEq) reduce boilerplate. Traits enable interface definitions and generic programming.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","typing"],"usage":{"struct":"Data containers with derives","enum":"Sum types for variants","trait":"Define interfaces/behaviors","newtype":"Type safety via wrapper structs"}}
{"id":"ADR-024","title":"Resource Management","status":"approved","decision":"Use RAII via Drop trait, smart pointers (Box, Rc, Arc) for heap allocation","rationale":"RAII guarantees cleanup. Rust's ownership system handles most resource management automatically. Use Arc<Mutex<T>> for shared mutable state.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns"]}
{"id":"ADR-025","title":"Dependency Injection","status":"approved","decision":"Constructor injection via new() methods, trait objects or generics for abstraction","rationale":"No DI framework needed in Rust. Use generics for compile-time dispatch, trait objects (dyn Trait) for runtime flexibility.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns","architecture"]}
{"id":"ADR-026","title":"Markdown Frontmatter Requirement","status":"approved","decision":"All markdown files MUST include YAML frontmatter with required fields: title, date, and version (or revised). Version uses semver (e.g., 1.0.0), revised uses ISO date (YYYY-MM-DD). At least one versioning field is mandatory.","rationale":"Frontmatter enables automated tooling, indexing, and change tracking. Version/revision fields provide clear document lifecycle management and audit trail.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["conventions","documentation"]}
{"id":"ADR-030","title":"CLI Framework","status":"approved","decision":"clap v4 with derive macros over structopt/argh","rationale":"Industry standard, excellent derive API, auto-generated help/completions, subcommand support. structopt merged into clap v3+.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","cli"],"features":["derive","cargo","env"]}
{"id":"ADR-031","title":"Environment Variables","status":"approved","decision":"dotenvy for .env files, clap env feature for CLI args from env","rationale":"dotenvy is maintained fork of dotenv. Clap can read CLI arguments from environment variables with the env feature.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["configuration","cli"]}
{"id":"ADR-040","title":"Web Framework","status":"approved","decision":"axum for web APIs, tower for middleware","rationale":"axum is built on hyper/tokio, excellent ergonomics, type-safe extractors, tower middleware ecosystem. By the tokio team.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["web","api"],"comparison":{"axum":"Modern, tower-based, ergonomic extractors","actix-web":"Mature, fast, actor-based","warp":"Filter-based, composable","rocket":"Macro-heavy, batteries-included"}}
{"id":"ADR-041","title":"HTTP Server","status":"approved","decision":"hyper via axum for HTTP serving","rationale":"hyper is the foundation of Rust's async HTTP ecosystem. axum provides the ergonomic layer on top.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["web","infrastructure"]}
{"id":"ADR-042","title":"API Protocol","status":"approved","decision":"REST by default, async-graphql for GraphQL when needed","rationale":"REST is simpler, better caching, widely understood. async-graphql is well-maintained and integrates with axum.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","architecture"]}
{"id":"ADR-043","title":"API Documentation","status":"approved","decision":"utoipa for OpenAPI generation from code","rationale":"Derive-based OpenAPI spec generation, integrates with axum, generates Swagger UI.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","documentation"],"crate":"utoipa"}
{"id":"ADR-044","title":"HTTP Client","status":"approved","decision":"reqwest for async HTTP client, ureq for sync-only contexts","rationale":"reqwest is async-first, built on hyper/tokio, excellent API. ureq for when you don't want tokio dependency.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","http"]}
{"id":"ADR-050","title":"Primary Database","status":"approved","decision":"PostgreSQL with sqlx for async database access","rationale":"sqlx provides compile-time query verification, async support, and works with PostgreSQL, MySQL, SQLite.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","infrastructure"],"crate":"sqlx"}
{"id":"ADR-051","title":"ORM/Query Builder","status":"approved","decision":"sqlx for raw SQL with compile-time checking, sea-orm for ORM when needed","rationale":"sqlx's compile-time verification catches SQL errors early. sea-orm provides ActiveRecord pattern for complex domain models.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","tooling"]}
{"id":"ADR-052","title":"Database Migrations","status":"approved","decision":"sqlx-cli for migrations","rationale":"Built into sqlx ecosystem, versioned migrations, supports both SQL files and embedded migrations.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","tooling"]}
{"id":"ADR-053","title":"Caching","status":"approved","decision":"redis crate for Redis, moka for in-process caching","rationale":"redis crate is mature and async-compatible. moka provides concurrent in-process cache with TTL support.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","caching"]}
{"id":"ADR-100","title":"Instant Visual Feedback","status":"approved","decision":"Every user action produces immediate visual feedback (<16ms for hover/drag, <50ms for property changes)","rationale":"Professional tools feel instant. Lag destroys direct manipulation illusion and user trust.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","performance"],"testQuestion":"Does it feel instant?"}
{"id":"ADR-101","title":"Undo Everything","status":"approved","decision":"Every state-modifying action is undoable. Undo history should be navigable.","rationale":"Fear of mistakes prevents experimentation. Users who can freely undo try more things and trust the tool more.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","state"],"testQuestion":"Can you Ctrl+Z this?"}
{"id":"ADR-102","title":"Progressive Disclosure","status":"approved","decision":"Simple things must be simple. Advanced features accessible but not in the way. UI scales from beginner to expert.","rationale":"New users are overwhelmed by complexity; experts frustrated by hidden features. Show basics by default, reveal advanced on demand.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","design"],"testQuestion":"Is simple stuff simple?"}
{"id":"ADR-103","title":"Production-Ready Output","status":"approved","decision":"Exported/generated code requires no cleanup before use in real projects","rationale":"If users must fix output, they question the tool's value. Output should match what a senior developer writes by hand.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","quality"],"testQuestion":"Would you ship this code?"}
{"id":"ADR-104","title":"Accessibility Native","status":"approved","decision":"The application must be accessible, and any output it generates must be accessible by default","rationale":"Accessible design improves usability for everyone. Accessibility debt is expensive to fix later.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","accessibility"],"testQuestion":"Can you use it without a mouse?"}
{"id":"ADR-105","title":"Performance Budget","status":"approved","decision":"Strict performance budget enforced. Features exceeding budget must be optimized or rejected.","rationale":"Performance degrades gradually then suddenly. Without a budget, death by a thousand cuts.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","performance"],"testQuestion":"Is it under budget?","budgets":{"apiResponse":"<50ms p95","startupTime":"<500ms","memoryIdle":"<50MB"}}
{"id":"ADR-106","title":"API Consistency","status":"approved","decision":"Consistent API design across all endpoints. Follow REST conventions or GraphQL best practices.","rationale":"Inconsistent APIs confuse developers and increase integration time. Predictable patterns enable faster development.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","quality"],"testQuestion":"Is the API predictable?"}
{"id":"ADR-107","title":"State Persistence and Recovery","status":"approved","decision":"User work never lost. State persists across sessions. Crash recovery is automatic.","rationale":"Losing work destroys trust. Auto-save and recovery are table stakes for professional tools.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","reliability"],"testQuestion":"Will this survive a crash?"}
{"id":"ADR-120","title":"Testing Strategy","status":"approved","decision":"Comprehensive test coverage with unit tests in modules, integration tests in tests/. Property-based testing with proptest for complex logic.","rationale":"Rust's type system catches many bugs, but tests verify behavior. Property-based testing finds edge cases.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","ci"],"libraries":{"property":"proptest","fuzzing":"cargo-fuzz"}}
{"id":"ADR-121","title":"Test Organization","status":"approved","decision":"Unit tests in #[cfg(test)] mod tests within each file, integration tests in tests/ directory","rationale":"Co-located unit tests have access to private items. Integration tests verify public API from external perspective.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","conventions"]}
{"id":"ADR-122","title":"Mocking Strategy","status":"approved","decision":"mockall for trait mocking, prefer dependency injection via generics","rationale":"Generics enable compile-time mock injection without runtime overhead. mockall for complex scenarios.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","patterns"]}
{"id":"ADR-123","title":"Async Testing","status":"approved","decision":"#[tokio::test] for async tests","rationale":"Native async test support via tokio macro, automatic runtime setup.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","async"]}
{"id":"ADR-124","title":"Benchmarking","status":"approved","decision":"criterion for benchmarks over built-in #[bench]","rationale":"Statistical rigor, HTML reports, stable Rust support. Built-in bench requires nightly.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","performance"],"crate":"criterion"}
{"id":"ADR-130","title":"CI/CD Pipeline","status":"approved","decision":"GitHub Actions with rust-toolchain.toml, caching via Swatinem/rust-cache","rationale":"rust-toolchain.toml pins versions. Rust-cache dramatically speeds up builds. Run fmt, clippy, test, and doc in parallel.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ci","infrastructure"],"stages":["cargo fmt --check","cargo clippy -- -D warnings","cargo test --all-features","cargo doc --no-deps"]}
{"id":"ADR-131","title":"Security Scanning","status":"approved","decision":"cargo-audit for dependency vulnerabilities, cargo-deny for license/duplicate checking","rationale":"cargo-audit checks RustSec advisory database. cargo-deny enforces license policies and detects duplicate deps.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["security","ci"],"tools":["cargo-audit","cargo-deny"]}
{"id":"ADR-132","title":"Container Deployment","status":"approved","decision":"Multi-stage Dockerfile with rust:slim for build, debian:slim or distroless for runtime","rationale":"Multi-stage builds produce small images. Rust binaries are statically linkable for minimal runtime images.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["infrastructure","deployment"]}
{"id":"ADR-133","title":"Release and Versioning Strategy","status":"approved","decision":"Semantic Versioning, Conventional Commits, annotated git tags (v*), CHANGELOG.md with Keep a Changelog format. Use cargo-release or release-plz for automation.","rationale":"Consistent versioning communicates compatibility. Conventional Commits enable automated changelogs. Cargo.toml is single source of truth for version.","createdAt":"2025-12-05","updatedAt":"2025-12-05","tags":["ci","versioning","releases"],"tools":{"automation":"cargo-release or release-plz","changelog":"git-cliff","commitlint":"commitlint-rs"},"versionSource":"Cargo.toml"}
{"id":"ADR-140","title":"Repository Naming and Taxonomy Standard","status":"approved","decision":"All repositories MUST follow strict four-segment hyphen-separated lowercase naming: <root>-<domain>-<type>-<name>. Per-repo metadata required in .github/repository.yaml.","rationale":"Discoverability, automation, security scoping, and onboarding require single enforceable taxonomy. Works identically across all project types.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["naming","taxonomy","conventions","governance"],"namingPattern":"<root>-<domain>-<type>-<name>"}